* 判断一个数在内存中的 1 的位数
  假设存在一个数 a, 则 a-1 的二进制必然比 a 的二进制少一个 1.
  因此只需要不断 a &= a-1, 直至 a 等于 0 为止, 求出 counter 即可.

* 取出一个数二进的最后一个 1
  a = a & (a ^ (a - 1))

* 寻找最小的 K 个数
  + 排序(n*logn)
  + 最大堆和最小堆, O(n*logk)
  + partition 算法, O(n)

* Two Sum
  + 排序, 二分查找, 时间:O(NlogN + NlogN)
  + hash, 时间: O(N), 空间 O(N)
  + 排序, 双指针, 时间:O(NlogN + N)

* 最大连续子数组和

* 最长子序列

* 最长子串

* 最长回文子串
